# Rust and WebAssembly Development Guide

> **A comprehensive guide to compiling Rust to WebAssembly for cross-platform, high-performance applications.**

## Overview

WebAssembly (WASM) is a portable binary instruction format that enables near-native performance in browsers and server-side runtimes. Rust's zero-cost abstractions, memory safety, and lack of runtime make it an ideal language for WASM targets.

---

## Quick Start

### 1. Install the Target

```bash
# Add WASM compilation target
rustup target add wasm32-unknown-unknown

# Install wasm-pack (recommended build tool)
cargo install wasm-pack

# Optional: Install wasm-opt for binary optimization
cargo install wasm-opt
```

### 2. Configure Cargo.toml

```toml
[package]
name = "my-wasm-lib"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wasm-bindgen = "0.2"

[profile.release]
opt-level = "z"        # Optimize for size
lto = true             # Link-time optimization
codegen-units = 1      # Better optimization
panic = "abort"        # Smaller binary (no unwinding)
strip = true           # Strip debug symbols
```

### 3. Write WASM-Compatible Code

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[wasm_bindgen]
pub struct Counter {
    value: i32,
}

#[wasm_bindgen]
impl Counter {
    #[wasm_bindgen(constructor)]
    pub fn new() -> Counter {
        Counter { value: 0 }
    }

    pub fn increment(&mut self) {
        self.value += 1;
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

### 4. Build and Use

```bash
# Build for web browsers
wasm-pack build --target web --release

# Build for Node.js
wasm-pack build --target nodejs --release

# Build for bundlers (webpack, etc.)
wasm-pack build --target bundler --release
```

```javascript
// JavaScript usage
import init, { add, Counter } from './pkg/my_wasm_lib.js';

async function main() {
    await init();
    console.log(add(2, 3));  // 5

    const counter = new Counter();
    counter.increment();
    console.log(counter.value());  // 1
}
```

---

## Core Toolchain

### Essential Tools

| Tool | Purpose | Install |
|------|---------|---------|
| `wasm-pack` | Build, test, publish WASM | `cargo install wasm-pack` |
| `wasm-bindgen` | Rust ↔ JavaScript bindings | Cargo dependency |
| `wasm-opt` | Binary optimizer (Binaryen) | `cargo install wasm-opt` |
| `wasm32-unknown-unknown` | Bare WASM target | `rustup target add ...` |
| `wasm32-wasip1` | WASI Preview 1 target | `rustup target add ...` |

### Key Crates

| Crate | Purpose |
|-------|---------|
| `wasm-bindgen` | JavaScript interop, type conversions |
| `js-sys` | Bindings to JS built-in objects (Array, Date, etc.) |
| `web-sys` | Bindings to Web APIs (DOM, fetch, WebGL, etc.) |
| `console_error_panic_hook` | Better panic messages in browser console |
| `wasm-bindgen-futures` | Async/await support, Promise integration |
| `gloo` | Ergonomic web API wrappers |

---

## Project Structure

```
my-wasm-project/
├── Cargo.toml
├── src/
│   ├── lib.rs           # WASM entry point
│   ├── utils.rs         # Pure Rust utilities (testable natively)
│   └── bindings.rs      # JavaScript interop code
├── tests/
│   └── web.rs           # WASM-specific tests
├── pkg/                 # Generated by wasm-pack
│   ├── my_wasm_lib.js
│   ├── my_wasm_lib.d.ts
│   ├── my_wasm_lib_bg.wasm
│   └── package.json
└── www/                 # Example web app
    ├── index.html
    └── index.js
```

---

## JavaScript Interop Patterns

### Exporting Functions

```rust
use wasm_bindgen::prelude::*;

// Simple function export
#[wasm_bindgen]
pub fn process_data(input: &str) -> String {
    input.to_uppercase()
}

// Export with different JS name
#[wasm_bindgen(js_name = processData)]
pub fn process_data_internal(input: &str) -> String {
    input.to_uppercase()
}
```

### Importing JavaScript Functions

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
extern "C" {
    // console.log
    #[wasm_bindgen(js_namespace = console)]
    fn log(s: &str);

    // alert
    fn alert(s: &str);

    // Document.getElementById
    #[wasm_bindgen(js_namespace = document)]
    fn getElementById(id: &str) -> JsValue;
}

pub fn debug_log(msg: &str) {
    log(msg);
}
```

### Working with Web APIs (web-sys)

```toml
# Cargo.toml - enable specific features
[dependencies.web-sys]
version = "0.3"
features = [
    "console",
    "Window",
    "Document",
    "Element",
    "HtmlElement",
    "Node",
]
```

```rust
use web_sys::{console, window, Document};

pub fn get_document() -> Option<Document> {
    window()?.document()
}

pub fn log_to_console(msg: &str) {
    console::log_1(&msg.into());
}
```

### Async/Await and Promises

```rust
use wasm_bindgen::prelude::*;
use wasm_bindgen_futures::JsFuture;
use web_sys::{Request, Response};

#[wasm_bindgen]
pub async fn fetch_data(url: &str) -> Result<JsValue, JsValue> {
    let window = web_sys::window().unwrap();
    let resp_value = JsFuture::from(window.fetch_with_str(url)).await?;
    let resp: Response = resp_value.dyn_into()?;
    JsFuture::from(resp.json()?).await
}
```

---

## Memory Management

### Linear Memory Model

WASM uses a single, contiguous memory buffer shared between Rust and JavaScript:

```
┌─────────────────────────────────────────┐
│              WASM Linear Memory         │
├─────────────────────────────────────────┤
│ Data Section (static data)              │
├─────────────────────────────────────────┤
│ Heap (Rust allocator manages this)      │
├─────────────────────────────────────────┤
│ Stack (function locals, return addrs)   │
└─────────────────────────────────────────┘
```

### Efficient Data Transfer

```rust
use wasm_bindgen::prelude::*;
use js_sys::Uint8Array;

// For large data, use typed arrays for zero-copy access
#[wasm_bindgen]
pub fn process_buffer(arr: &Uint8Array) -> Uint8Array {
    let data: Vec<u8> = arr.to_vec();
    let result: Vec<u8> = data.iter().map(|x| x.wrapping_mul(2)).collect();
    Uint8Array::from(&result[..])
}

// Pre-allocate buffers to avoid repeated allocations
static mut BUFFER: [u8; 1024 * 1024] = [0; 1024 * 1024];

#[wasm_bindgen]
pub fn get_buffer_ptr() -> *mut u8 {
    unsafe { BUFFER.as_mut_ptr() }
}
```

### Memory Best Practices

1. **Minimize boundary crossings** — Batch operations instead of many small calls
2. **Use typed arrays** — `Uint8Array`, `Float32Array` for bulk data
3. **Pre-allocate buffers** — Avoid allocation in hot paths
4. **Copy, don't share** — Safer than sharing pointers across boundaries

---

## Error Handling

### Returning Results to JavaScript

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn divide(a: f64, b: f64) -> Result<f64, JsValue> {
    if b == 0.0 {
        Err(JsValue::from_str("Division by zero"))
    } else {
        Ok(a / b)
    }
}
```

### Panic Handling

```rust
use wasm_bindgen::prelude::*;

// Set up panic hook for browser console errors
#[wasm_bindgen(start)]
pub fn init() {
    console_error_panic_hook::set_once();
}
```

```toml
[dependencies]
console_error_panic_hook = "0.1"
```

### Zero-Panic Pattern (Recommended)

```rust
use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn safe_operation(input: &str) -> Result<String, JsValue> {
    if input.is_empty() {
        return Err(JsValue::from_str("Input cannot be empty"));
    }

    serde_json::from_str::<serde_json::Value>(input)
        .map(|v| v.to_string())
        .map_err(|e| JsValue::from_str(&format!("Parse error: {}", e)))
}
```

---

## Binary Size Optimization

### Cargo.toml Settings

```toml
[profile.release]
opt-level = "z"        # 'z' for smallest, 's' for balanced, '3' for fastest
lto = true             # Link-time optimization (10-25% smaller)
codegen-units = 1      # Single codegen unit (better optimization)
panic = "abort"        # No unwinding (10-15% smaller)
strip = true           # Strip symbols (30-50% smaller)
```

### Additional Techniques

```bash
# Use wasm-opt for further optimization
wasm-opt -Oz input.wasm -o output.wasm

# Enable WASM-specific optimizations
RUSTFLAGS="-C target-feature=+simd128" wasm-pack build --release
```

### Size Reduction Checklist

| Technique | Typical Savings |
|-----------|-----------------|
| `panic = "abort"` | 10-15% |
| `opt-level = "z"` | 20-30% |
| `lto = true` | 10-25% |
| `strip = true` | 30-50% |
| `wasm-opt -Oz` | 5-15% |
| Use `#![no_std]` | Varies (significant) |

### Custom Allocator for Size

```rust
// Use wee_alloc for smaller binary (trades performance for size)
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;
```

```toml
[dependencies]
wee_alloc = "0.4"
```

---

## Testing WASM Code

### Native Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
}
```

### Browser Tests

```rust
// tests/web.rs
#![cfg(target_arch = "wasm32")]

use wasm_bindgen_test::*;

wasm_bindgen_test_configure!(run_in_browser);

#[wasm_bindgen_test]
fn test_in_browser() {
    assert_eq!(my_wasm_lib::add(1, 2), 3);
}

#[wasm_bindgen_test]
async fn test_async_fetch() {
    let result = my_wasm_lib::fetch_data("/api/data").await;
    assert!(result.is_ok());
}
```

```toml
[dev-dependencies]
wasm-bindgen-test = "0.3"
```

### Running Tests

```bash
# Native tests
cargo test

# Browser tests
wasm-pack test --headless --chrome
wasm-pack test --headless --firefox

# Node.js tests
wasm-pack test --node
```

---

## Performance Considerations

### When WASM Excels

| Use Case | Typical Speedup |
|----------|-----------------|
| Image/video processing | 2-10x |
| Cryptography | 3-20x |
| Physics simulations | 2-5x |
| Audio processing | 2-8x |
| Data compression | 3-10x |
| Game engines | 2-4x |

### When WASM May Not Help

| Scenario | Reason |
|----------|--------|
| DOM manipulation | Must cross JS boundary |
| Simple calculations | Call overhead dominates |
| I/O-bound operations | Waiting, not computing |
| Frequent small calls | Boundary crossing cost |
| String-heavy operations | Serialization overhead |

### Minimizing Boundary Overhead

```javascript
// ❌ BAD: Many boundary crossings
for (let i = 0; i < pixels.length; i++) {
    pixels[i] = wasmModule.processPixel(pixels[i]);
}

// ✅ GOOD: Single boundary crossing
const ptr = wasmModule.allocate(pixels.length);
new Uint8Array(memory.buffer, ptr, pixels.length).set(pixels);
wasmModule.processAllPixels(ptr, pixels.length);
pixels.set(new Uint8Array(memory.buffer, ptr, pixels.length));
```

---

## Conditional Compilation

### Target Detection

```rust
#[cfg(target_arch = "wasm32")]
mod wasm_impl {
    // WASM-specific implementation
}

#[cfg(not(target_arch = "wasm32"))]
mod native_impl {
    // Native implementation
}

// Platform-agnostic interface
pub fn do_work() {
    #[cfg(target_arch = "wasm32")]
    wasm_impl::work();

    #[cfg(not(target_arch = "wasm32"))]
    native_impl::work();
}
```

### Feature Flags

```toml
[features]
default = ["std"]
std = []
wasm = ["wasm-bindgen", "js-sys", "web-sys"]

[target.'cfg(target_arch = "wasm32")'.dependencies]
wasm-bindgen = "0.2"
web-sys = { version = "0.3", features = ["console"] }
```

---

## WASI (Server-Side WASM)

### Building for WASI

```bash
rustup target add wasm32-wasip1
cargo build --target wasm32-wasip1 --release
```

### Running with Wasmtime

```bash
# Install wasmtime
curl https://wasmtime.dev/install.sh -sSf | bash

# Run WASI module
wasmtime target/wasm32-wasip1/release/my_app.wasm
```

### WASI vs Browser WASM

| Feature | Browser WASM | WASI |
|---------|--------------|------|
| File system | ❌ No | ✅ Yes |
| Network | Via JS fetch | Via WASI sockets |
| Environment vars | ❌ No | ✅ Yes |
| Command-line args | ❌ No | ✅ Yes |
| Sandboxing | Browser sandbox | Capability-based |

---

## Resources

- **Official Book**: [Rust and WebAssembly](https://rustwasm.github.io/docs/book)
- **wasm-bindgen Guide**: [wasm-bindgen documentation](https://rustwasm.github.io/docs/wasm-bindgen/)
- **web-sys API**: [web-sys crate docs](https://docs.rs/web-sys)
- **WASI**: [WASI documentation](https://wasi.dev/)
- **MDN WebAssembly**: [MDN WebAssembly Guide](https://developer.mozilla.org/en-US/docs/WebAssembly)

---

*WebAssembly enables portable, high-performance code that runs safely in browsers and server environments.*
